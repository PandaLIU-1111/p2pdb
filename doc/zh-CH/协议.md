无冲突复制数据类型#
由于可以使用直接传输进行在线和离线通信，因此必须有一种方法来保持所有消息之间的连贯性和顺序，尤其是在与多个参与者的对话中。例如，如果 Alice 和 Bob 与其他几个人在一个聊天组中，并且他们都因乘坐地铁而失去了互联网连接，那么他们仍然可以使用 BLE 在同一对话中相互通信，从而创建此对话的并行版本。当他们重新上线时，BLE 版本和 Internet 版本将不得不合并。因此，有必要使用一种算法来确保所有对等方在同步后具有完全相同的排序消息列表。

这个问题的解决方案是无冲突复制数据类型 (CRDT)，它是一种数据结构，允许在分布式系统上对消息进行一致的排序,CRDT 提供乐观复制和强最终一致性，确保一旦同步，每个对等点都将具有相同版本的消息列表。

每条消息都链接到其父级，这是此时连接在一起的对等方之一在对话中发送的最后一条消息。当对话的在线和离线版本同步时会出现问题：一些消息链接到同一个父级，链表变成有向无环图 。


![avatar](https://d33wubrfki0l68.cloudfront.net/8563a307fdd30972608022cae35fdb94055b2f40/4fd9e/docs/protocol/bkfkkbdou_hub6782b1aaace488361b88eb59d953e58_133009_970x0_resize_q100_lanczos_2.webp)


这会导致创建几个最终需要合并的并行分支。OrbitDB 通过使用Lamport Clock 来实现这一点：每条消息将包含一个，合并后的列表将根据其值进行排序。

Lamport 时钟是一个包含两个字段的结构：一个身份公钥和一个计数器，该计数器为相关用户/身份发布的每条消息递增。

```
// golang
type lamportClock struct {
    time int
    id   crypto.PublicKey
}
```

比较函数很简单，它会首先检查计数器值之间的距离，如果没有，它会检查身份公钥之间的字典距离，知道给定的身份不能用相同的计数器发布两条消息价值。


```
// golang
func compareClock(a, b lamportClock) int {
    dist := a.time - b.time

    if dist == 0 {
        dist = comparePubKey(a.id, b.id) // Returns lexicographic distance
    }

    return dist
}
```